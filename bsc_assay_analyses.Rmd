---
title: "Bush stone-curlew behaviour and performance analyes"
author: "Shoshana Rapley"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Load packages
pacman::p_load(beepr, ggpubr, glmmTMB, janitor, performance, readxl, sjPlot, survival, tidyverse)

# Bird list excluding Daisy (returned to captivity) & Star (disease fate)
birds <- c("Briar", "Nutmeg", "Aurora", "Robin",
           "Iona", "Sage", "Koda", "Brook", "Clover",
           "Prem", "Rove", "Valentine", "Marmalade", "Wobbles")
```

# Introduction

This Markdown documents analyses done as part of paper '<insert name here>', a chapter of my doctoral studies. 

The aim of this study is to test whether we can predict post-release performance using pre-release assays in translocated bush stone-curlews. If true, we might be able screen for suitable release candidates in future translocations. 

In this study we translocated 16 bush stone-curlews into the Mt Rothwell fenced sancatuary from the Mt Rothwell breeding colony. They were released in October 2022 to January 2023 across three release groups. This was the pilot release at the site (i.e., no conspecifics prior to the translocation and a high degree of risk and uncertainty), which is why we released in a 'drip feed' manner over the Summer of 2022/23. 

Two individuals were excluded from analyses. Daisy was returned to captivity after two days due to risky behaviour (hanging around the buildings in a high traffic area). Star died of gastroenteritis shortly after release and so her fate was not linked to behaviour. 

# Predictors

We undertook pre-release assays prior to release of the birds. The pre-release assays were:

* Latency to reach food
* Handling response
* Vigilance

These took place in their home aviaires in the captive breeding colony and were filmed with trail cameras.

## Latency

Latency to reach food was defined as how long it took each bird, in seconds, to reach a plate of food provided as part of their normal husbandry. It was measured from when the plate was placed on the ground until the bird took the first mouthful. 

```{r latency data}
# Read in and clean up latency assay data
latency <- read_excel("Input/bsc assay data.xlsx", sheet =3) %>%
  clean_names() %>%
  # Select study birds
  filter(bird %in% birds) %>%
  # Filter to assay dates
  filter(date %in% c("2022-10-12", "2022-10-11")) %>%
  select(c("date", "bird", "reach", "latency_s")) %>%
  # Convert yes/no to 1/0
  mutate(reach = ifelse(reach == "Yes", 1, 0)) %>%
  rename(latency = latency_s) %>%
  # Add column for plotting 'did not reach'
  mutate(label = ifelse(is.na(latency), "DNR", "")) %>%
  # Convert latency NAs to zeros
  mutate(latency = ifelse(is.na(latency), 0, latency))

# Plot latency by bird
ggplot(latency) + 
  geom_bar(aes(bird, latency, fill = as.character(date)), 
           position = "dodge", stat = "identity")+
  geom_text(aes(y=600, x= bird, label = label), angle = 90, vjust = -0.5)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= element_blank(), y = "Latency to reach food (seconds)")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_fill_manual(values = c("#881C00FF","#1BB6AFFF"), name = "Assay date")+
  theme_minimal()
```

We need to account for repeat measures but due to low sample size we cannot use bird as a random factor (model convergence issues when tested). So instead, we are going to use the mean latency.

```{r mean latency}
# Calculate mean latency by bird
mlatency <- latency %>% group_by(bird) %>%
  summarise(latency = mean(latency))

# Plot mean latency by bird
ggplot(mlatency) + 
  geom_bar(aes(bird, latency), position = "dodge", stat = "identity")+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= element_blank(), y = "Mean latency to reach food (seconds)")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_fill_manual(values = c("#881C00FF","#1BB6AFFF"), name = "Assay date")+
  theme_minimal()
```

## Handling response

Handling response was assigned during processing, and is an ordinal variable on a scale of 1:3:

1) Calm/still/log-pose
2) Moderate/slight kicking or struggling/soft calling or beak clacking
3) Extreme/upset/shrieking/growling

```{r handling}
# Read in handling data
handling <- read_excel("Input/bsc assay data.xlsx", sheet = 7) %>%
  clean_names() %>%
  rename(bird = identity) %>%
  # Filter to study birds
  filter(bird %in% birds) %>%
  # Filter to assay dates
  filter(date %in% c("2022-10-20"))

# Plot frequency of handling scores
ggplot(handling)+
  geom_bar(aes(score))+
  scale_y_continuous(breaks =c(1,3,5,7,9))+
  theme_minimal()
```

Most birds (64%) had a handling score of 1, with 21% a score of 2 and just two individuals (14%) with a score of 3. 

As a side note, where we have repeat measures (i.e., taken post-release- but these aren't documented here) the handling response stays the same; however, for now we are just interested in whether the pre-release assay values predict other post-release behaviours. 

### Vigilance

Birds were filmed in their aviaries between 12pm-4pm. For every film recorded (activited by the infrared sensor on the trail camera) we encoded each second of behaviour for each bird. We calculated the the proportion of time spent in vigilant behaviours (considered mutually exclusive from 'relaxed' behaviours). 

*Vigilant behaviours* were defined as:

* Alertness: standing but not relaxed, often startled into this pose from a more relaxed posture. May have a stiffer pose, holding neck extended or forward. May have flattened the feathers against the body. 
* Alert walk: walking with the neck stiffly extended parallel wit hthe ground. Feathers either fluffed up (held erect) or slimmed against body, as opposed to held loosely. 
* Head-bobbing: a rapid up/down movement of the head; used to communicate unease.
* Head-tilting: craning the head to the side to look above and around; possibly to check for danger (can be done in tandem with head-bobbing).
* Tail-wagging: a rapid side/side shake of the tail; used to communicate unease.
* Defensive display: holding the wings outstretched; often wings are rapidly extended which gives the impression of a black and white 'flash' of plumage.

*Relaxed behaviours* were defined as:

* Preening: actively cleaning self (i.e., running the beak along the feathers, rearranging plumage), or scratching (e.g. the face with the toes), or stretching (e.g. extending the leg and wing).
* Fluffing: a rapid erection and flattening of the feathers, often accompanied by a body and head shake. Often preceded by preening. 
* Standing: relaxed pose (in the absence of vigilant behaviours as defined above), feathers loose or lightly fluffed (as opposed to erect or flat against the body).
* Walking: stepping forward (in the absence of vigilant behaviours as defined above).
* sitting: either on tibiotarsus or fully on the ground; includes sleeping. 
* Eating: engaged in looking at, carrying, pecking, picking up, swallowing or breaking up food (or non food items that are being tested e.g. leaves). Can rapidly (second by second) change between eating and alertness. 

Here we read in the video assay data and calculate the time spent vigilant as a proportion of whole time. Some videos have sections where the bird is out of frame (noted in ethogram as 'Z'), which are excluded from the time allocation analysis. 

```{r vigilance}
# Read in and tidy up video assays 
video <- read_excel("Input/bsc assay data.xlsx", sheet =4) %>%
  clean_names() %>%
  # Drop metadata columns
  select(-c("clip", "note")) %>%
  # Convert from wide to long
  pivot_longer(3:61, names_to = "second", values_to = "behaviour") %>%
  # Convert seconds into numeric
  mutate(second = as.numeric(str_remove(second, "x"))) %>%
  # Assign vigilance to 1 and not to 0
  mutate(vigilant = ifelse(behaviour %in% 
                             c("A","HT","HB","HBT","N","TW","D"), 1, 0)) %>%
  # Drop lines without recordings (primarily for Prem and Rove who had 10 second clips)
  na.omit()

# Calculate time spent vigilant
vigilance <- video %>%
  group_by(bird) %>%
  summarise(z = sum(grepl("Z", behaviour)),
            L = length(behaviour) - z,
            v = sum(vigilant),
            pv = v/L)

# Plot proportion of time spent vigilant by bird
ggplot(vigilance) + 
  geom_bar(aes(bird, pv), position = "dodge", stat = "identity")+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= element_blank(), y = "Proportion of time spent vigilant")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  theme_minimal()
```

# Responses

Here we consider post-release performance in terms of survival. We tracked birds with GPS devices to determine their fate. The GPS devices were removed in January 2024. Because different cohorts were released at different times (October, December or January), the maximum tracked duration is 360 days. To standardise among groups, the max persistence was set to 360 days.

We assessed survival in three ways:

* survival to 90-days post-release (yes/no; binary)
* survival to 1-year post-release (yes/no; binary)
* persistence (how many days survived; continuous)

We tested survival to both 90-days and 1-year post-release becasue we wanted to know whether the time period of monitoring impacted the strength of prediction. We chose 90-days because this was the typical tracking duration in previous bush stone-curlew translocation when tracking was done with VHF (which was at Mulligans Flat in 2014-2016).

```{r survival}
# Read in survival data
survival <- read.csv("Input/survival.csv") %>%
  clean_names() %>%
  rename(bird = identity) %>%
  filter(bird %in% birds) %>%
  # Limit persistence value to minimum common tracked time of 360
  mutate(persist = ifelse(persist>360, 360, persist))
```

# Analyses
## Latency and survival

Combine predictor (latency) and response (survival).

```{r m1}
# Combine survival and latency data
m1_data <- survival %>%
  select(c("bird", "persist", "to_90", "to_360")) %>%
  left_join(latency)
```

There are two levels of response for latency to reach food: 

1) Did the bird reach the food (yes/no)
2) How long did it take the bird to reach the food?

### m1a: latency ~ survival (90 days)

*Does latency to reach food predict survival to 90-days post-release?*

First we looked at the distribution of responses of whether they reached the food with survival. 

```{r reach food 90 days}
# Survived to 90 days
mosaicplot(table(m1_data$to_90, m1_data$reach))
chisq.test(table(m1_data$to_90, m1_data$reach))
```

The birds didn't reach the food on one third of occasions, but all birds reached the food at least once (out of two trials). From here on we'll just use the time to reach the food.

We used a binomial family glm because the response variable (survival) is binary.

```{r m1a}
# Drop DNRs
m1_data <- filter(m1_data, !label == "DNR")

# m1a: Does latency to reach food predict survival? To 90 days.
ggplot(m1_data)+
  geom_boxplot(aes(x= to_90, y=log(latency), group=to_90))+
  theme_minimal()

m1a <- glmmTMB(to_90 ~ scale((latency)),
           data = m1_data,
           family = binomial)

summary(m1a)

check_model(m1a)
```

Remember to say cannot use random effects because issues with model convergence due to low sample size. Include comment on model performance sub optimal 

Ideally I should have used date as a random factor (because some two-thirds of the birds have two latency scores), but the model wasn't able to handle this and gave me an error that "negative log-likelihood is NaN at starting parameter values". 

Perhaps I should use a hurdle model - first did they reach the food and then how long it took to reach the food?

### m1b: latency ~ survival (1 year)

*Does latency to reach food predict survival to 1-year post-release?*

First we looked at the distribution of responses of whether they reached the food with survival. 

```{r reach food 1 year}
# Survived to 360 days
mosaicplot(table(m1_data$to_360, m1_data$reach))
chisq.test(table(m1_data$to_360, m1_data$reach))
```

As before, we used a binomial family glm because the response variable (survival) is binary.

```{r m1b}
# m1b: Does latency to reach food predict survival? To 360 days.
ggplot(m1_data)+
  geom_boxplot(aes(x= to_360, y=log(latency), group=to_360))+
  theme_minimal()

m1b <- glmmTMB(to_360 ~ scale(log(latency)),
           data = m1_data,
           family = binomial)
summary(m1b)

check_model(m1b)

```

### m1c: latency ~ persistence
*Does latency to reach food predict persistence?*

First, we checked the distribution of the response variable (persistence) to select the appropriate glm model family. 

```{r persist}
hist(m1_data$persist)
hist(log(m1_data$persist))
```

The persistence values are duration (e.g. zero or higher) and have a right-skewed distribution; therefore a negative binomial regression model should be suitable.

```{r m1c}
# m1c: Does latency to reach food predict persistence?
ggplot(m1_data, aes(persist, log(latency)))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_minimal()

m1c <- glmmTMB(persist ~ scale(log(latency)) + (1|bird),
           data = m1_data)

summary(m1c)

check_model(m1c)
```

Weak evidence that latency predicts persistence. Aagain, should this be a hurdle (first reach then latency)?

## Handling response and survival

Combine predictor (handling score) and response (survival).

```{r m2}
m2_data <- survival %>%
  select(c("bird", "persist", "to_90", "to_360")) %>%
  left_join(handling) %>%
  mutate(score = as_factor(score))
```

### m2a: handling response ~ survival (90 days)
*Does handling response predict survival to 90-days post-release?*

```{r m2a}
mosaicplot(table(m2_data$to_90, m2_data$score))
chisq.test(table(m2_data$to_90, m2_data$score))
```

### m2b: handling response ~ survival (1 year)
*Does handling response predict survival to 1-year post-release?*

```{r m2b}
mosaicplot(table(m2_data$to_360, m2_data$score))
chisq.test(table(m2_data$to_360, m2_data$score))
```

While there is no evidence for a prediction here (on the chi-squared test, keeping in mind low sample size) there are some interesting observations we can make: 1) Both birds with a handling score of 3 survived. 2) No birds with a handling score of 2 survived. Perhaps an intermediate strategy is suboptimal i.e., it's better to either commit to full camouflage or full flight, not the middle ground. Perhaps the middle ground is evidence of habituation, since both scores 1 and 3 can be considered a predator-response behaviour (flight or camouflage). 

#### m2c: handling response ~ persistence
*Does handling response predict persistence?*

Since handling score is categorical, we'll use ANOVA and chi-squared to compare frequencies. 

```{r m2b}
# Does handling response predict persistence?
ggplot(m2_data)+
  geom_boxplot(aes(score, persist, group = score))+
  theme_minimal()

m2c <- aov(persist ~ score,
           data = m2_data)
summary(m2c)
```

All the score 3 birds do well. 

Interestingly, the persistence time for score 2 individuals is pretty long (195 & 308 days) - which contradicts my earlier thoughts about score 2 being maladaptive. Instead, it looks like there are a range of score 1 individual persistence values.

Overall, there is no evidence that handling score predicts persistence. 


## Vigilance and survival

Combine predictor (handling score) and response (survival).

```{r m3}
# Join vigilance and survival data
m3_data <- survival %>%
  select(c("bird", "persist", "to_90", "to_360")) %>%
  left_join(vigilance)
```

### m3a: vigilance ~ survival (90 days)
*Does vigilance predict survival to 90-days post-release?*

We use a binomial family glm because the response variable (survival) is binary.

```{r m3a}
# m3a: Does vigilance predict survival to 90 days>
ggplot(m3_data)+
  geom_boxplot(aes(to_90, pv))+
  labs(y = "Proportion of time spent vigilant")+
  theme_minimal()

m3a <- glmmTMB(to_90 ~ pv,
           data = m3_data,
           family = binomial)

summary(m3a)
```

### m3b: vigilance ~ survival (1 year)
*Does vigilance predict survival to 1-year post-release?*

We use a binomial family glm because the response variable (survival) is binary.

```{r m3b}
# m3b: Does vigilance predict survival to 1 year?
ggplot(m3_data)+
  geom_boxplot(aes(to_360, pv))+
  labs(y = "Proportion of time spent vigilant")+
  theme_minimal()

m3b <- glmmTMB(to_360 ~ pv,
           data = m3_data,
           family = binomial)
summary(m3b)
```


No evidence that proportion of time spent vigilant predicts survival. 

#### m3b: vigilance ~ persistence
*Does vigilance predict persistence?*

As before, we use a negative binomial regression model because of the right-skewed persistence values. 

```{r m3b}
# m3b: Does vigilance predict persistence?
ggplot(m3_data, aes(persist, pv))+
  geom_point()+
  geom_smooth(method = "lm")+
  labs(y = "Proportion of time spent vigilant")+
  theme_minimal()

m3b <- glmmTMB(persist ~ pv,
           data = m3_data,
           family = nbinom2(link = "log"))
summary(m3b)
```

No relationship. Although most vigilant bird (Iona) survived full time period. 

That's all of the predictors against survival/persistence. Looks like none of the metrics predicted survival. But maybe we'll be able to predict sub-lethal effects or behaviours that might influence future survival and reproduction.




### Hazard rate

I also want to try using a survival analysis approach, since 'persistence' is a time-to-event response. 

First I plot the survival curve to see if the hazard rate is constant over time (although this is tough with n=13).

```{r hazard, eval=FALSE}
# Add every day for survival
birds2 <- setdiff(birds, c("Daisy", "Star"))
survival2 <- data.frame()

for(i in 1:length(birds2)){
  temp <- subset(survival, bird == birds2[i]) %>%
    mutate(start_date = as_date(start_date, format = "%d/%m/%Y"),
           end_date = as_date(end_date, format = "%d/%m/%Y"))

  temp2 <- data.frame(date = as_date(temp$start_date:as_date("2024-01-10"))) %>%
  mutate(bird = birds2[i],
         status = ifelse(date<temp$end_date, 1, 0),
         # Convert dates to numeric for use in Surv()
         time = date - as_date(temp$start_date))
  
  survival2 <- rbind(survival2, temp2)
}

survival3 <- left_join(survival2, latency2) %>%
  left_join(select(handling, c(bird, score))) %>%
  mutate(score = as_factor(score))

# Plot hazard rate 
plot(survfit(Surv(time, status) ~ 1, data = survival2))

summary(survfit(Surv(time, status) ~ 1, data = survival2))


test <- coxph(Surv(time, status) ~ scale(latency) + score, data = survival3)
summary(test)
plot_model()
plot_model(test, type = "pred")
```

The hazard rate is approximately linear (i.e., constant), so we should be able to use a Cox proportional hazard model rather than a parametric survival model. 



