---
title: "Bush stone-curlew behaviour and performance analyes"
author: "Shoshana Rapley"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)

# Load packages
pacman::p_load(beepr, ggpubr, janitor, performance, readxl, sjPlot, survival, tidyverse)

# Bird list excluding Daisy (returned to captivity) & Star (disease fate)
birds <- c("Briar", "Nutmeg", "Aurora", "Robin",
           "Iona", "Sage", "Koda", "Brook", "Clover",
           "Prem", "Rove", "Valentine", "Marmalade", "Wobbles")
```

# Introduction

This Markdown documents analyses done as part of paper 'captive behaviour predicts translocation performance in bush stone-curlews', a chapter of my doctoral studies. 

The aim of this study is to test whether we can predict post-release performance using pre-release assays in translocated bush stone-curlews. If true, we might be able screen for suitable release candidates in future translocations. 

In this study we translocated 16 bush stone-curlews into the Mt Rothwell fenced sancatuary from the Mt Rothwell breeding colony. They were released in October 2022 to January 2023 across three release groups. This was the pilot release at the site (i.e., no conspecifics prior to the translocation and a high degree of risk and uncertainty), which is why we released in a 'drip feed' manner over the Summer of 2022/23. 

Two individuals were excluded from analyses. Daisy was returned to captivity after two days due to risky behaviour (hanging around the buildings in a high traffic area). Star died of gastroenteritis shortly after release and so her fate was not linked to behaviour. 

# Predictors

We undertook pre-release assays prior to release of the birds. The pre-release assays were:

a) Latency to reach food
b) Handling response (in-hand)
c) Filmed behaviour

Predictors A and C were filmed in their home aviaries with trail cameras. Predictor B was scored during routine handling.

## Latency

Latency to reach food was defined as how long it took each bird, in seconds, to reach a plate of food provided as part of their normal husbandry. It was measured from when the plate was placed on the ground until the bird took the first mouthful. 

```{r latency data}
# Read in and clean up latency assay data
latency <- read_excel("Input/bsc assay data.xlsx", sheet =3) %>%
  clean_names() %>%
  # Select study birds
  filter(bird %in% birds) %>%
  # Filter to assay dates
  filter(date %in% c("2022-10-12", "2022-10-11")) %>%
  dplyr::select(c("date", "bird", "reach", "latency_s")) %>%
  # Convert yes/no to 1/0
  mutate(reach = ifelse(reach == "Yes", 1, 0)) %>%
  rename(latency = latency_s) %>%
  # Add column for plotting 'did not reach'
  mutate(label = ifelse(is.na(latency), "DNR", ""))

# Plot latency by bird
ggplot(latency) + 
  geom_bar(aes(bird, latency, fill = as.character(date)), 
           position = "dodge", stat = "identity")+
  geom_text(aes(y=600, x= bird, label = label), angle = 90, vjust = -0.5)+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= element_blank(), y = "Latency to reach food (seconds)")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_fill_manual(values = c("#881C00FF","#1BB6AFFF"), name = "Assay date")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())
```

We need to account for repeat measures but due to low sample size we cannot use bird as a random factor (model convergence issues when tested). So instead, we are going to use the mean latency. The birds didn't reach the food on one third of occasions, but all birds reached the food at least once (out of two trials).

```{r mean latency}
# Calculate mean latency by bird
mlatency <- latency %>% 
  na.omit() %>%
  group_by(bird) %>%
  summarise(latency = mean(latency))

# Plot mean latency by bird
ggplot(mlatency) + 
  geom_bar(aes(bird, latency), position = "dodge", stat = "identity")+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(x= element_blank(), y = "Mean latency to reach food (seconds)")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_fill_manual(values = c("#881C00FF","#1BB6AFFF"), name = "Assay date")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())

# Check the distribution of mean latency
hist(mlatency$latency)
shapiro.test(mlatency$latency)
qqnorm(mlatency$latency)

# Transform mean latency
hist(sqrt(mlatency$latency))
shapiro.test(sqrt(mlatency$latency))
qqnorm(sqrt(mlatency$latency))
```

I applied a square-root transformation to latency because the data was left-skewed. The Shapiro-Wilks test for normalcy showed the pre-transformed data were non-normally distributed while the post-corrected data were (better, but still imperfectly) normally distributed. 

## Handling response

Handling response was assigned during processing, and is an ordinal variable on a scale of 1:3:

1) Calm/still/log-pose
2) Moderate/slight kicking or struggling/soft calling or beak clacking
3) Extreme/upset/shrieking/growling

```{r handling}
# Read in handling data
handling <- read_excel("Input/bsc assay data.xlsx", sheet = 7) %>%
  clean_names() %>%
  rename(bird = identity) %>%
  # Filter to study birds
  filter(bird %in% birds) %>%
  # Filter to assay dates
  filter(date %in% c("2022-10-20")) %>%
  # Drop unneeded columns
  dplyr::select(c(bird, score))

# Plot frequency of handling scores
ggplot(handling)+
  geom_bar(aes(score))+
  scale_y_continuous(breaks =c(1,3,5,7,9))+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())
```

Most birds (64%) had a handling score of 1, with 21% a score of 2 and just two individuals (14%) with a score of 3. 

As a side note, where we have repeat measures (i.e., taken post-release- but these aren't documented here) the handling response stays the same; however, for now we are just interested in whether the pre-release assay values predict other post-release behaviours. 

## Behaviour

Birds were filmed in their aviaries between 12pm-4pm. For every film recorded (activated by the infrared sensor on the trail camera) we encoded each second of behaviour for each bird. We calculated the the proportion of time spent in alert behaviours (considered mutually exclusive from 'relaxed' behaviours). 

*Alert behaviours* were defined as:

* Alertness: standing but not relaxed, often startled into this pose from a more relaxed posture. May have a stiffer pose, holding neck extended or forward. May have flattened the feathers against the body. 
* Postured walk: walking with the neck stiffly extended parallel wit the ground. Feathers either fluffed up (held erect) or slimmed against body, as opposed to held loosely. 
* Head-bobbing: a rapid up/down movement of the head; used to communicate unease.
* Head-tilting: craning the head to the side to look above and around; possibly to check for danger (can be done in tandem with head-bobbing).
* Tail-wagging: a rapid side/side shake of the tail; used to communicate unease.
* Defensive display: holding the wings outstretched; often wings are rapidly extended which gives the impression of a black and white 'flash' of plumage.

*Relaxed behaviours* were defined as:

* Preening: actively cleaning self (i.e., running the beak along the feathers, rearranging plumage), or scratching (e.g. the face with the toes), or stretching (e.g. extending the leg and wing).
* Fluffing: a rapid erection and flattening of the feathers, often accompanied by a body and head shake. Often preceded by preening. 
* Standing: relaxed pose (in the absence of vigilant behaviours as defined above), feathers loose or lightly fluffed (as opposed to erect or flat against the body).
* Walking: stepping forward (in the absence of vigilant behaviours as defined above).
* sitting: either on tibiotarsus or fully on the ground; includes sleeping. 
* Eating: engaged in looking at, carrying, pecking, picking up, swallowing or breaking up food (or non food items that are being tested e.g. leaves). Can rapidly (second by second) change between eating and alertness. 
* Calling: calling as part of group crescendo with "werloo" song (as opposed to short contact calls while doing other beahviours such as sitting or standing)

Here we read in the video assay data and calculate the time spent vigilant as a proportion of whole time. Some videos have sections where the bird is out of frame (noted in ethogram as 'Z'), which are excluded from the time allocation analysis. 

```{r behaviours}
# Ethogram
eth <- matrix(c("A", "Alert",
                "C", "Calling",
                "D", "Defensive wing display",
                "E", "Eating/drinking",
                "F", "Fluff",
                "HB", "Head bob",
                "HT", "Head tilt",
                "I", "Sitting",
                "N", "Camouflaged walk",
                "O", "Courtship",
                "P", "Preening",
                "S", "Standing",
                "W", "Walking",
                "TW", "Tail wag",
                "Z", "Out of frame"),
              ncol = 2, byrow = TRUE) %>%
  as.data.frame() %>%
  rename(code = V1,
         Behaviour = V2)

# Assign plotting order of behaviours
order <- c("Alert", "Head bob", "Head tilt", "Tail wag", "Camouflaged walk", 
           "Defensive wing display", "Calling", "Eating/drinking", "Courtship",
           "Fluff", "Preening", "Sitting", "Standing", "Walking", "Out of frame")

# Read in and tidy up video assays 
behaviour <- read_excel("Input/bsc assay data.xlsx", sheet =4) %>%
  clean_names() %>%
  # Drop metadata columns
  dplyr::select(-c("clip", "note")) %>%
  # Convert from wide to long
  pivot_longer(3:61, names_to = "second", values_to = "code") %>%
  # Convert seconds into numeric
  mutate(second = as.numeric(str_remove(second, "x"))) %>%
  # Drop instances of out of frame 
  filter(!code == "Z") %>%
  # Lump all variations of head tilt 
  mutate(code = ifelse(code %in% c("HBT", "HTB", "HTW"), "HT", code)) %>%
  # Add behaviour descriptions from ethogram
  left_join(eth) %>%
  # Turn behaviour into a factor to assign order for plotting
  mutate(Behaviour = factor(Behaviour, levels = order)) %>%
  # Assign vigilance to 1 and not to 0
  mutate(vigilant = ifelse(code %in% 
                             c("A", "D", "HB", "HT", "TW", "N"), 1, 0)) %>%
  # Drop lines without recordings (primarily for Prem and Rove who had 10 second clips)
  na.omit()

# Plot proportion of time spent in each behaviour per bird
ggplot(behaviour) + 
  geom_bar(aes(x= bird, fill = Behaviour), position = "fill")+
  labs(x= element_blank(), 
       y = "Proportion of time spent in each behaviour")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  theme_minimal()+
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank())+
  scale_fill_viridis_d(direction = -1)

# Calculate proportion of time spent in each behaviour and a summed 'alert' metric
time <- count(behaviour, bird) %>%
  rename(total = n)
prop_behav <- count(behaviour, bird, code) %>%
  left_join(time) %>%
  # Divide count of behaviour by total time for %
  mutate(prop = n/total) %>%
  dplyr::select(-c(n, total)) %>%
  # Pivot wider, one column per behaviour
  pivot_wider(names_from = code, values_from = prop) %>%
  # Replace NAs for behaviour with zeroes
  replace(is.na(.), 0) %>%
  # Add column for summed 'alert' measure
  mutate(alert = A + HB + HT + TW + N + D)

# Plot time spent alert
ggplot(prop_behav) +
  geom_bar(aes(x= bird, y= alert), position = "dodge", stat = "identity")+
  labs(x= element_blank(), 
       y = "Proportion of time spent in alert behaviours")+
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  theme_minimal()+
  theme(panel.grid.minor = element_blank())

# Check distribution of behaviours
hist(prop_behav$alert)

# Summarise allocation of behaviours
prop_behav_sum <- prop_behav %>%
  summarise(across(where(is.numeric),list(mean = mean, sd = sd))) %>%
  pivot_longer(1:30)
```

Interestingly, the amount of time spent 'alert' (yellows and greens) seems (visually at least) inversely related to the amount of time spent eating (aqua), rather than cutting in to the time spent resting (purples). 

The 'alert' metric is close to normally distributed. 

## Traits

I included some non-behavioural trait predictors to compare with the assays predictions. These included life-history and morphological traits.

```{r traits}
# Read in additional bird metadata
meta <- read_excel("Input/bsc assay data.xlsx", sheet = 8) %>%
  clean_names() %>%
  rename(bird = individual) %>%
  select(c(bird, sex, age))

# And pre-release weights
weights <- read_excel("Input/bsc assay data.xlsx", sheet = 9) %>%
  clean_names() %>%
  select(c(identity, weight, condition)) %>%
  rename(bird = identity)

# And morphometrics 
traits <- read_excel("Input/bsc assay data.xlsx", sheet = 10) %>%
  clean_names()  %>%
  select(c(identity, wing, tail, tarsus)) %>%
  rename(bird = identity) %>%
  filter(bird %in% birds) %>%
  # Combine all traits data
  left_join(meta) %>%
  left_join(weights)

```

Out of curiosity, I want to know whether the traits are correlated.

```{r traits 2}
# Weight and condition by sex
ggplot(traits, aes(x= condition, y= weight, fill = sex))+
  geom_boxplot()+
  geom_jitter()+
  theme_minimal()

# Weight and tarsus by sex
ggplot(traits, aes(x= tarsus, y= weight, fill = sex))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_minimal()

# Wind chord and tarsus by sex
ggplot(traits, aes(x= wing, y= tarsus, fill = sex))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_minimal()
```

1) Males weigh more than females. Weight in the 'good' condition score varies more for females compared to males.
2) Females have in general a smaller weight:tarsus ratio than males, but with sex overlap.
3) Males have a larger tarsus than females but wing lenght only differs at the extremes.

I didn't end up using the morphometric data in the models due to convergence issues with low sample sizes. 

# Responses

We tracked birds with GPS devices to determine their fate. The GPS devices were removed in January 2024. Because different cohorts were released at different times (October, December or January), the maximum tracked duration is 360 days. 

We assessed survival in three ways:

* survival to 90-days post-release (yes/no; binary)
* survival to 1-year post-release (yes/no; binary)
* persistence (how many days survived; continuous)

We tested survival to both 90-days and 1-year post-release becasue we wanted to know whether the time period of monitoring impacted the strength of prediction. We chose 90-days because this was the typical tracking duration in previous bush stone-curlew translocation when tracking was done with VHF (which was at Mulligans Flat in 2014-2016).

```{r survival}
# Read in survival data
survival <- read.csv("Input/survival.csv") %>%
  clean_names() %>%
  rename(bird = identity) %>%
  filter(bird %in% birds) %>%
  # Limit persistence value to minimum common tracked time of 360
  mutate(persist = ifelse(persist>360, 360, persist)) %>%
  # Convert true and false to 0 and 1
  mutate(to_90 = ifelse(to_90 == FALSE, 0, 1),
         to_360 = ifelse(to_360 == FALSE, 0, 1)) %>%
# Drop unneeded columns
  dplyr::select(c(bird, persist, to_90, to_360, start_date, end_date))

# Check the distribution of persistence and test some transformations
hist(survival$persist)
hist(sqrt(survival$persist))
hist(log(survival$persist))

# Combine survival with all predictors
data <- left_join(survival, mlatency) %>%
  left_join(handling) %>%
  left_join(prop_behav) %>%
  left_join(traits) %>%
  # Drop un-needed behaviour columns
  dplyr::select(-c(A, C, E, F, HB, HT, N, O, P, S, TW, W, D, I))
```

Persistence data remained right skewed despite tested transformations. Instead, can use a Gamma family in the glm() call to account for positively skewed data (with the default log link because all values are >0). 

For the survival to 90-days and 1-year, we use a binomial family glm (because responses are binary; with the default logit link). 

# Analyses
## Model selection approach
Instead of assessing each predictor separately, here I throw all of them into a single model along with the traits to see what best predicts survival/persistence.

```{r m1a}
# m1a: What predicts survival to 90 days?
m1a <- glm(to_90 ~ sqrt(latency) + alert + as.factor(score) + as.factor(sex) + weight,
           data = data,
           family = binomial())

anova(m1a, test = "Chi")

check_model(m1a)
```

The best predictor for survival to 90-days was weight (significant), followed by latency (marginally significant). 

```{r m1b}
# m1b: What predicts survival to 1 year?
m1b <- glm(to_360 ~ sqrt(latency) + alert + as.factor(score) + as.factor(sex) + weight,
           data = data,
           family = binomial())

anova(m1b, test = "Chi")

check_model(m1b)
```

The best predictor for survival to 1-year was again weight(significant), then sex (significant), followed by handling score (significant). 

Interestingly, the predictors differed by time period - highlighting the importance of monitoring duration and also the different survival pressures between short and mid term post-release. 

Since behaviour (the 'alert' metric) didn't predict survival to either time period, I won't investigate this further. Which is a shame since it was the most time consuming metric to create (around 60 hours)! At least this might reduce the effort future practitioners need to go to. 

## Latency and survival
The relationship between reaching food and survival was not significant in either time period.

In the model selection (m1a and m1b), sqrt(latency) weakly predicted survival to 90-days but not to 1-year. Let's have a closer look at these. 

*Does latency to reach food predict survival to 90-days post-release?*

```{r m2a}
# m2a: Does latency to reach food predict survival? To 90 days.
## Violin plot
ggplot(data, aes(x= to_90, y=sqrt(latency), group=to_90))+
  geom_violin()+
  geom_point(size = 2)+
  labs(x= "Survival to 90-days post-release", 
       y = "Latency to reach food (squareroot transformed)")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())+
  scale_x_continuous(breaks = c(0,1), labels = c(FALSE, TRUE))

## Logistic regression with binomial family
m2a <- glm(to_90 ~ sqrt(latency),
           data = data,
           family = binomial())

summary(m2a)

# Survival probability
exp(coef(m1a))
```

Only three birds (21%) died in the period to 90-days post-release. There is weak evidence (i.e. marginally significant prediction) that shorter latency periods predict survival. 

When latency approaches zero the chance of survival is 82% (based on the intercept coefficient estimate). With every unit increase in sqrt(latency), the odds of survival decrease by a factor of 0.94.

Model performance is imperfect, with non-normally distributed residuals. Given the management needs to balance risk and uncertainty during translocation, I would use this imperfect information to inform the translocation approach until better information can be gathered for adaptive management. Since lower latency *might* inform survival, and we want to reduce unnecessary mortality, this is a useful management tool. 

Next, we looked at the effect of latency on survival to 1-year post-release. 

*Does latency to reach food predict survival to 1-year post-release?*

```{r m2b}
# m2b: Does latency to reach food predict survival? To 360 days.
## Violin plot
ggplot(data, aes(x= to_360, y=sqrt(latency), group=to_360))+
  geom_violin()+
  geom_point(size = 2)+
  labs(x= "Survival to 1-year post-release", 
       y = "Latency to reach food (squareroot transformed)")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())+
  scale_x_continuous(breaks = c(0,1), labels = c(FALSE, TRUE))

## Logistic regression with binomial family
m2b <- glm(to_360 ~ sqrt(latency),
           data = data,
           family = binomial())

summary(m2b)
```

Just under half of the birds (42%, n = 6) survived to the 1-year post-release period. The chance of survival increases with decreasing latency values. However, unlike for 90-days, the effect is not significant. This could indicate that latency has a more immediate impact on short-term survival but less influence on long-term survival.

Potentially, whatever behavioural traits are related to latency (perhaps risk:reward trade-off or drive for food) only relates to survival in the period immediately following release. Perhaps this is due to the drive to find food resources during establishment, but this effect does not impact long-term survival which is (likely) more related to anti-predation traits, rather than resource-related traits.

This highlights the importance of sampling period and the different drives of survival in the short and long term post-release.

In summary, latency only has a meaningful impact on short-term survival (to 90 days), not overall persistence across the 1-year study period. 

## Handling response and survival

Since handling score is categorical, we'll use ANOVA and chi-squared to compare frequencies. 

*Does handling response predict survival to 90-days post-release?*

```{r m3a}
mosaicplot(table(data$to_90, data$score), 
           main = NULL, 
           xlab = "Survival to 90-days post-release",
           ylab = "Handling score")

chisq.test(table(data$to_90, data$score))
```

*Does handling response predict survival to 1-year post-release?*

```{r m3b}
mosaicplot(table(data$to_360, data$score), 
           main = NULL, 
           xlab = "Survival to 1-year post-release",
           ylab = "Handling score")

chisq.test(table(data$to_360, data$score))
```

While there is no evidence of a relationship between handling score and survival to 90-days, there is weak evidence of a relationship to 1-year.

Some interesting observations:

1) Both birds with a handling score of 3 survived. 
2) No birds with a handling score of 2 survived. 

Perhaps an intermediate strategy is sub-optimal i.e., it's better to either commit to full camouflage or full flight, not the middle ground. Perhaps the middle ground is evidence of habituation, since both scores 1 and 3 can be considered a predator-response behaviour (flight or camouflage). 

While latency to reach food better predicted survival to 90-days, handling response better predicted survival to 1-year. As discussed earlier, perhaps that is because these assay approaches measure different traits. I think latency may be related to resource acquisition while handling may be related to anti-predator response. 

Interestingly, the persistence for score 2 individuals is pretty long (195 & 308 days) - which contradicts my earlier thoughts about score 2 being maladaptive. 

Overall, there is weak evidence that handling score predicts persistence. In the context of adaptive management (the same as for the latency score), I would use this information to inform management until better information can be gathered. That is, preferentially release score 3 birds when risk and uncertainty are high. I would not release score 2 birds during a pilot study, but perhaps they can be used later in a reintroduction program. 

In summary, handling score is a better predictor of long-term surival (1 year) than latency. 

## Weight and survival

The best predictor for survival in both periods was weight. I investigate this separately here. 

```{r m4}
# m4a: Does weight predict survival? To 90 days.
## Violin plot
ggplot(data, aes(x= to_90, y=weight, group=to_90))+
  geom_violin()+
  geom_point(size = 2)+
  labs(x= "Survival to 90-days post-release", 
       y = "Pre-release weight")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())+
  scale_x_continuous(breaks = c(0,1), labels = c(FALSE, TRUE))

## Logistic regression with binomial family
m4a <- glm(to_90 ~ weight,
           data = data,
           family = binomial())
summary(m4a)

# m4b: Does weight predict survival? To 1 year.
## Violin plot
ggplot(data, aes(x= to_360, y=weight, group=to_360))+
  geom_violin()+
  geom_point(size = 2)+
  labs(x= "Survival to 1-year post-release", 
       y = "Pre-release weight")+
  theme_minimal()+
  theme(panel.grid.minor = element_blank())+
  scale_x_continuous(breaks = c(0,1), labels = c(FALSE, TRUE))

## Logistic regression with binomial family
m4b <- glm(to_360 ~ weight,
           data = data,
           family = binomial())
summary(m4b)
```

## Sex and survival

A predictor for survival to 1-year was sex I investigate this separately here. 

```{r m5}
# m5a: Does weight predict survival? To 90 days.
## Mosaic plot
mosaicplot(table(data$to_90, data$sex), 
           main = NULL, 
           xlab = "Survival to 90-days post-release",
           ylab = "Sex")

chisq.test(table(data$to_90, data$sex))

# m5b: Does weight predict survival? To 1 year.
## Mosaic plot
mosaicplot(table(data$to_360, data$sex), 
           main = NULL, 
           xlab = "Survival to 1-year post-release",
           ylab = "Sex")

chisq.test(table(data$to_360, data$sex))
```

Sex did not predict survival in either time period. The issue is there are only 2 males not surviving to 360 and none not surviving to 90 days. There isn't enough predictive power. But it is interesting to mention. I wonder if sex is coming up as important because the males are bigger and bigger birds are surviving better? 

## Survival analysis

To look at persistence I am using a survival analysis approach, since 'persistence' is a time-to-event response. 

```{r hazard rate}
# Bring in data and format as Surv() for Kaplan Meier Analysis
km <- data %>%
  rename(time = persist,
         status = to_360)

km_fit <- survfit(Surv(persist, to_360) ~ 1, km)

summary(km_fit, times = c(1,90, 180, 270, 359))

plot(km_fit, xlab="Days", main = 'Kaplan Meyer Plot')
```


First I plot the survival curve to see if the hazard rate is constant over time (although this is tough with n=14).

```{r hazard}
# Add every day for survival
surv <- data.frame()

for(i in 1:length(birds)){
  temp <- subset(survival, bird == birds[i]) %>%
    mutate(start_date = as_date(start_date, format = "%d/%m/%Y"),
           end_date = as_date(end_date, format = "%d/%m/%Y"))

  temp2 <- data.frame(date = as_date(temp$start_date:as_date("2024-01-10"))) %>%
  mutate(bird = birds[i],
         status = ifelse(date<temp$end_date, 1, 0),
         # Convert dates to numeric for use in Surv()
         time = date - as_date(temp$start_date))
  
  surv <- rbind(surv, temp2)
}

hazard <- left_join(surv, data) %>%
  dplyr::select(-c(persist, to_90, to_360, start_date, end_date))

# Plot hazard rate 


surv <- with(data, Surv(persist, to_360))


plot(survfit(Surv(time, status) ~ 1, data = hazard))

summary(survfit(Surv(time, status) ~ 1, data = hazard))

test <- coxph(Surv(time, status) ~ scale(latency) + score, data = hazard)

summary(test)
plot_model()
plot_model(test, type = "pred")
```

The hazard rate is approximately linear (i.e., constant), so we should be able to use a Cox proportional hazard model rather than a parametric survival model. 